#开关量
 &emsp;&emsp;在嵌入式系统中的都会不同的方式将系统运行状态传送给用户，LED可以说是嵌入式系统中最简单的方式之一，本章简单介绍如何设计LED接口电路，对比应用操作系统与不用的异同。

&emsp;&emsp;本节主要目的介绍有无操作系统程序实现细节的差别。
在本章中以LED显示为例介绍RT-Thread操作系统线程管理相关的内容，并给出线程设计模型，以供设计者使用

书中所用开发套件关于开关量有三个外设可以进行演示，分类是LED、蜂鸣器、键盘。
##STM32 IO硬件介绍
STM32F系统处理器GPIO随着型号不同个数也不经相同 。以STM32F103VC 100引脚的为例,在100个引脚中除电源，时钟，模拟电路输入参考源之外所有的80个引脚均可配置成为不同的模式进行工作。
在STM32中每个脚可通过配置成不同的模式，进行功能在图 3 3 GPIO端口位的基本结构中表明每个引脚/端口输入输出中可选配置选项。可以通过配置寄存器行设置，比较繁琐，在ST官方提供的库中已对各功能进行划分，在库中以宏定义的形式给出。下面进行介绍。
![GPIO端口位的基本结构](/figures/ch03-gpio-bit.png)
**GPIO主要特性**

+ 输出状态可选推挽、开漏、上拉/下拉
+ 每个I/O速度可配置
+ 输入状态可选悬空、上位/下拉、模拟
+ I/O引脚功能复用
+ 可对GPIO每个引脚进行位操作


&emsp;&emsp;输入浮空、输入上拉、输入下拉、模拟输入、开漏输出、推挽式输出、推挽式复用功能、开漏复用功能；工作模式GPIO_Mode在STM32库中以枚举型定义如下：
~~~{.c}
/* stm32f10x_gpio.h */
typedef enum
{ 
	GPIO_Mode_AIN = 0x0,          //模拟输入
	GPIO_Mode_IN_FLOATING = 0x04,//浮空输入
	GPIO_Mode_IPD = 0x28,         //下拉输入
    GPIO_Mode_IPU = 0x48,         //上拉输入
    GPIO_Mode_Out_OD = 0x14,      //开漏输出
    GPIO_Mode_Out_PP = 0x10,      //推挽式输出
    GPIO_Mode_AF_OD = 0x1C,       //推挽式复用功能
    GPIO_Mode_AF_PP = 0x18        //开漏复用功能
}GPIOMode_TypeDef;
~~~
&emsp;&emsp;GPIO最大输出速度根据需要可配置为2M、10M、50M进行工作，最大输出速度在STM32库中以枚举型定义如下：
~~~{.c}
/* stm32f10x_gpio.h */
typedef enum
{ 
    GPIO_Speed_10MHz = 1,
    GPIO_Speed_2MHz, 
    GPIO_Speed_50MHz
}GPIOSpeed_TypeDef;

~~~
##外围器件介绍

**LED基本知识**
发光二极管（Light Emitting Diode），是一种能够将电能转化为可见光的固态半导休器件，当电流流过LED时就会产生可视的光，LED的发光强度与通过LED的电流成正比如图5-1所示。目前常用的LED有红色、黄色、蓝色等。
![LED工作原理](/figures/led.png)
**按键**

**蜂鸣器**
##电路设计
**LED电路图**
![LED电路图](/figures/led1-sch.png)
<p align = "center">led电路图</p>
<p align = "center">张新院</p>
##GPIO硬件相关函数
```c
/* stm32f10x_gpio.c */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
```
**功能** 
根据GPIO_InitStruct中指定的参数进行初始化外设GPIOx寄存器。
************
**参数**
**************************
GPIOx		        通过x来选择GPIO外设,如GPIOA、GPIOE等
GPIO_InitStruct 	指向结构GPIO_InitTypeDef的指针，包含外设GPIO的配置信息
*********************
GPIO_InitTypeDef    中可以指定引脚、GPIO工作速度和工作模式。
********************************
**返回值**  无

**范例**
```c
/* rt_hw_led.c */
void rt_hw_led_init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    .
    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_5;       	  //指定第五引脚
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_PP;   //工作模式
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   //工作速度
    GPIO_Init(GPIOE, &GPIO_InitStructure);           	   //初始化
}
```
注：引脚选中是通过`GPIO_Pin_x`选定，选定多个`GPIO_Pin_5|GPIO_Pin_6`表示指定第5位和每六位，`x`可为`0`到`15`
 
**GPIO置位操作**
```c
/* stm32f10x_gpio.c */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
```
##驱动模型
下图显示了led模块的程序接口，给应用程序提供3个接口函数，`led_init()、led_on()、led_off()`分别实现对led1、led2、led3、led4的初始化和led点亮和熄灭操作。
![led驱动抽象框图](/figures/led-control-mode.png)
`rt_hw_led_init()`完成对led1、led2、led3、led4硬件的初始化；在实例中，应用

###初始化线程`rt_thread_init()`

```c
/* thread.c */
rt_err_t rt_thread_init(struct rt_thread *thread,
                        const char         *name,
                       	void 		(*entry)(void *parameter),
                        void             	 *parameter,
                        void             	 *stack_start,
                        rt_uint32_t    	 stack_size,
                        rt_uint8_t		 priority,
                        rt_uint32_t		 tick)

```
**功能描述：**
> 用来初始化静态线程对象。而线程句柄（或者说线程控制块指针），线程栈由用户提供。静态线程是指，线程控制块、线程运行栈一般都设置为全局变量，在编译时就被确定、被分配处理，内核不负责动态分配内存空间。需要注意的是，用户提供的栈首地址需做系统对齐（例如ARM 上需要做4 字节对齐）。

<center>**函数参数**<center>
---
    参数	    描述
---

1. *thread   线程句柄。线程句柄由用户声明(struct rt_thread led_thread;)，并指向对应     线程控制块的内存地址，声明的线程句柄就是线程一个代号，所有对线程的操作者是句柄进行的。

**注意事项**

**范例**
```c
/* 线程句柄声明 */
static struct rt_thread led_thread;
/* 线程堆栈声明 */
static rt_uint8_t led_stack[ 512 ];
/* 线程入口 */
static void led_thread_entry(void* parameter)
{
...
}
/* 用户应用入口 */
int rt_application_init()
{
rt_err_t result;
/* 初始化 led_thread */
result = rt_thread_init(&led_thread,	//页
                          "led",					//线程名为led
                          led_thread_entry, 		//线程入口
                          RT_NULL,          		//没有参数
                          (rt_uint8_t*)&led_stack[0], 
                          sizeof(led_stack), 
                          20, 
                          5);
 if (result == RT_EOK)   //如果返回正确，启动线程led_thread
     rt_thread_startup(&led_thread);
 else
     return -1;
    
    return 0;
}
```


**范例说明：** 创建线程led_thread，线程入口函数为led_thread_entry，传递的堆栈的首地址为&led_stack[0]，确定线程的优先级以及相同优先级下分到的时间片。

### 线程创建 ###

-----
		所在文件		调用者		配置
------
	rt-thread.c		线程或中断		o
---
```c
    rt_thread_t rt_thread_create(const char* name,
                                 void (*entry)(void* parameter), void* parameter,
                                 rt_uint32_t stack_size,
                                 rt_uint8_t priority, rt_uint32_t tick);
```


一个线程要成为可执行的对象就必须由操作系统的内核来为它创建（初始化）一个线程句柄。可以通过如下的函数接口来创建一个线程。


调用这个函数时，系统会从动态堆内存中分配一个线程句柄（即TCB，线程控制块）以及按照参数中指定的栈大小从动态堆内存中分配相应的空间。分配出来的栈空间是按照rtconfig.h中配置的RT_ALIGN_SIZE方式对齐。






**函数参数**

-----------------------------------------------------------------------
           参数  描述
--------------  -------------------------------------------------------
          name  线程的名称；线程名称的最大长度由rtconfig.h中定义的
                RT_NAME_MAX宏指定，多余部分会被自动截掉。

         entry  线程入口函数

     parameter  线程入口函数参数；

    stack_size  线程栈大小，单位是字节。在大多数系统中需要做栈空间地址对齐（例如ARM体系结构中需要向4字节地址对齐）。

      priority  线程的优先级。优先级范围根据系统配置情况（rtconfig.h中的RT_THREAD_PRIORITY_MAX宏定义），如果支持的是256级优先级，那么范围是从0 ～ 255，数值越小优先级越高，0代表最高优先级。

          tick  线程的时间片大小。时间片（tick）的单位是操作系统的时钟节拍。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。这个时间片运行结束时，调度器自动选择下一个就绪态的同优先级线程进行运行。
-----------------------------------------------------------------------


**函数返回**

创建成功返回线程句柄；否则返回RT_NULL。

* 注：确定一个线程的栈空间大小，是一件令人头痛的事情。在RT-Thread中，可以先指定一个稍微大的栈空间，例如指定大小为1024或2048，然后在FinSH shell中通过list_thread()命令查看线程运行的过程中线程所使用的栈的大小，通过此命令，能够看到从线程启动运行时，到当前时刻点，线程使用的最大栈深度，从而可以确定栈空间的大小并加以修改)。
![状态转移](http://i.imgur.com/xWS8KE7.jpg)
下面举例创建一个线程加以说明：

~~~{.c}
/*
 * 程序清单：动态线程
 *
 * 这个程序会初始化2个动态线程：
 * 它们拥有共同的入口函数，相同的优先级
 * 但是它们的入口参数不相同
 */
#include <rtthread.h>

#define THREAD_PRIORITY         25
#define THREAD_STACK_SIZE       512
#define THREAD_TIMESLICE        5

/* 指向线程控制块的指针 */
static rt_thread_t tid1 = RT_NULL;
static rt_thread_t tid2 = RT_NULL;
/* 线程入口 */
static void thread_entry(void* parameter)
{
    rt_uint32_t count = 0;
    rt_uint32_t no = (rt_uint32_t) parameter; /* 获得正确的入口参数 */

    while (1)
    {
        /* 打印线程计数值输出 */
        rt_kprintf("thread%d count: %d\n", no, count ++);

        /* 休眠10个OS Tick */
        rt_thread_delay(10);
    }
}

/* 用户应用入口 */
int rt_application_init()
{
    /* 创建线程1 */
    tid1 = rt_thread_create("t1",
        thread_entry, (void*)1, /* 线程入口是thread_entry, 入口参数是1 */
        THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_TIMESLICE);
    if (tid1 != RT_NULL)
        rt_thread_startup(tid1);
    else
        return -1;

    /* 创建线程2 */
    tid2 = rt_thread_create("t2",
        thread_entry, (void*)2, /* 线程入口是thread_entry, 入口参数是2 */
        THREAD_STACK_SIZE, THREAD_PRIORITY, THREAD_TIMESLICE);
    if (tid2 != RT_NULL)
        rt_thread_startup(tid2);
    else
        return -1;

    return 0;
}
~~~
